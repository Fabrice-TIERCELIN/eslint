/**
 * @fileoverview Disallow redundant continue statements
 * @author Fabrice TIERCELIN
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils"),
    FixTracker = require("./utils/fix-tracker");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Removes the given element from the array.
 * @param {Array} array The source array to remove.
 * @param {any} element The target item to remove.
 * @returns {void}
 */
function remove(array, element) {
    const index = array.indexOf(element);

    if (index !== -1) {
        array.splice(index, 1);
    }
}

/**
 * Checks whether it can remove the given continue statement or not.
 * @param {ASTNode} node The continue statement node to check.
 * @returns {boolean} `true` if the node is removable.
 */
function isRemovable(node) {
    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}

/**
 * Checks whether the given continue statement is in a `finally` block or not.
 * @param {ASTNode} node The continue statement node to check.
 * @returns {boolean} `true` if the node is in a `finally` block.
 */
function isInFinally(node) {
    for (
        let currentNode = node;
        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);
        currentNode = currentNode.parent
    ) {
        if (currentNode.parent.type === "TryStatement" && currentNode.parent.finalizer === currentNode) {
            return true;
        }
    }

    return false;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "disallow redundant continue statements",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-useless-continue"
        },

        fixable: "code",
        schema: [],

        messages: {
            unnecessaryContinue: "Unnecessary continue statement."
        }
    },

    create(context) {
        const segmentInfoMap = new WeakMap();
        const usedUnreachableSegments = new WeakSet();
        const sourceCode = context.getSourceCode();
        let scopeInfo = null;

        /**
         * Checks whether the given segment is terminated by a continue statement or not.
         * @param {CodePathSegment} segment The segment to check.
         * @returns {boolean} `true` if the segment is terminated by a continue statement, or if it's still a part of unreachable.
         */
        function isContinued(segment) {
            const info = segmentInfoMap.get(segment);

            return !info || info.returned;
        }

        /**
         * Collects useless continue statements from the given previous segments.
         *
         * A previous segment may be an unreachable segment.
         * In that case, the information object of the unreachable segment is not
         * initialized because `onCodePathSegmentStart` event is not notified for
         * unreachable segments.
         * This goes to the previous segments of the unreachable segment recursively
         * if the unreachable segment was generated by a continue statement. Otherwise,
         * this ignores the unreachable segment.
         *
         * This behavior would simulate code paths for the case that the continue
         * statement does not exist.
         * @param {ASTNode[]} uselessContinues The collected continue statements.
         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.
         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call
         * @returns {ASTNode[]} `uselessContinues`.
         */
        function getUselessContinues(uselessContinues, prevSegments, providedTraversedSegments) {
            const traversedSegments = providedTraversedSegments || new WeakSet();

            for (const segment of prevSegments) {
                if (!segment.reachable) {
                    if (!traversedSegments.has(segment)) {
                        traversedSegments.add(segment);
                        getUselessContinues(
                            uselessContinues,
                            segment.allPrevSegments.filter(isContinued),
                            traversedSegments
                        );
                    }
                    continue;
                }

                uselessContinues.push(...segmentInfoMap.get(segment).uselessContinues);
            }

            return uselessContinues;
        }

        /**
         * Removes the continue statements on the given segment from the useless continue
         * statement list.
         *
         * This segment may be an unreachable segment.
         * In that case, the information object of the unreachable segment is not
         * initialized because `onCodePathSegmentStart` event is not notified for
         * unreachable segments.
         * This goes to the previous segments of the unreachable segment recursively
         * if the unreachable segment was generated by a continue statement. Otherwise,
         * this ignores the unreachable segment.
         *
         * This behavior would simulate code paths for the case that the continue
         * statement does not exist.
         * @param {CodePathSegment} segment The segment to get continue statements.
         * @returns {void}
         */
        function markContinueStatementsOnSegmentAsUsed(segment) {
            if (!segment.reachable) {
                usedUnreachableSegments.add(segment);
                segment.allPrevSegments
                    .filter(isContinued)
                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))
                    .forEach(markContinueStatementsOnSegmentAsUsed);
                return;
            }

            const info = segmentInfoMap.get(segment);

            for (const node of info.uselessContinues) {
                remove(scopeInfo.uselessContinues, node);
            }
            info.uselessContinues = [];
        }

        /**
         * Removes the continue statements on the current segments from the useless
         * continue statement list.
         *
         * This function will be called at every statement except FunctionDeclaration,
         * BlockStatement, and BreakStatement.
         *
         * - FunctionDeclarations are always executed whether it's returned or not.
         * - BlockStatements do nothing.
         * - BreakStatements go the next merely.
         * @returns {void}
         */
        function markContinueStatementsOnCurrentSegmentsAsUsed() {
            scopeInfo
                .codePath
                .currentSegments
                .forEach(markContinueStatementsOnSegmentAsUsed);
        }

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return {

            // Makes and pushs a new scope information.
            onCodePathStart(codePath) {
                scopeInfo = {
                    upper: scopeInfo,
                    uselessContinues: [],
                    codePath
                };
            },

            // Reports useless continue statements if exist.
            onCodePathEnd() {
                for (const node of scopeInfo.uselessContinues) {
                    context.report({
                        node,
                        loc: node.loc,
                        messageId: "unnecessaryContinue",
                        fix(fixer) {
                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {

                                /*
                                 * Extend the replacement range to include the
                                 * entire function to avoid conflicting with
                                 * no-else-return.
                                 * https://github.com/eslint/eslint/issues/8026
                                 */
                                return new FixTracker(fixer, sourceCode)
                                    .retainEnclosingFunction(node)
                                    .remove(node);
                            }
                            return null;
                        }
                    });
                }

                scopeInfo = scopeInfo.upper;
            },

            /*
             * Initializes segments.
             * NOTE: This event is notified for only reachable segments.
             */
            onCodePathSegmentStart(segment) {
                const info = {
                    uselessContinues: getUselessContinues([], segment.allPrevSegments),
                    returned: false
                };

                // Stores the info.
                segmentInfoMap.set(segment, info);
            },

            // Adds ContinueStatement node to check whether it's useless or not.
            ContinueStatement(node) {
                if (node.label) {
                    markContinueStatementsOnCurrentSegmentsAsUsed();
                }
                if (
                    node.label ||
                    !astUtils.isInLoop(node) ||
                    isInFinally(node) ||

                    // Ignore `continue` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)
                ) {
                    return;
                }

                for (const segment of scopeInfo.codePath.currentSegments) {
                    const info = segmentInfoMap.get(segment);

                    if (info) {
                        info.uselessContinues.push(node);
                        info.returned = true;
                    }
                }
                scopeInfo.uselessContinues.push(node);
            },

            /*
             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
             * Removes continue statements of the current segments from the useless continue statement list.
             */
            ClassDeclaration: markContinueStatementsOnCurrentSegmentsAsUsed,
            DebuggerStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            DoWhileStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            EmptyStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ExpressionStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ForInStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ForOfStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ForStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            IfStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ImportDeclaration: markContinueStatementsOnCurrentSegmentsAsUsed,
            LabeledStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ReturnStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            SwitchStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ThrowStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            TryStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            VariableDeclaration: markContinueStatementsOnCurrentSegmentsAsUsed,
            WhileStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            WithStatement: markContinueStatementsOnCurrentSegmentsAsUsed,
            ExportNamedDeclaration: markContinueStatementsOnCurrentSegmentsAsUsed,
            ExportDefaultDeclaration: markContinueStatementsOnCurrentSegmentsAsUsed,
            ExportAllDeclaration: markContinueStatementsOnCurrentSegmentsAsUsed
        };
    }
};
